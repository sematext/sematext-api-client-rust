/* 
 * Sematext Cloud API
 *
 * API Explorer provides access and documentation for Sematext REST API. The REST API requires the API Key to be sent as part of `Authorization` header. E.g.: `Authorization : apiKey e5f18450-205a-48eb-8589-7d49edaea813`.
 *
 * OpenAPI spec version: v3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
#![allow(unused_imports)]

use serde_json::Value;
use bigdecimal::BigDecimal;
use chrono::{Date, NaiveDateTime, NaiveDate, DateTime, FixedOffset, Utc};

use crate::models::*;
use crate::date_serializer;
use crate::date_serializer_opt;
use crate::serialize_quoted_numbers;
use crate::serialize_quoted_numbers_opt;
//Uncomment this to deal with limited rfc support on server side
//use crate::datetime_serializer::*;

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct UsageDto {
  #[serde(rename = "dailyUsage")]
  #[serde(default)]
  daily_usage: Option<Vec<DailyDto>>, 
  #[serde(rename = "dailyVolumeMB")]
  #[serde(default)]
  daily_volume_mb: Option<i64>, 
  #[serde(rename = "end")]
  #[serde(default)]
  //Uncomment this also to deal with limited rfc support on server side
  //#[serde(serialize_with = "serialize_dt", deserialize_with = "deserialize_dt")]
  end: Option<DateTime<Utc>>, 
  #[serde(rename = "failedCount")]
  #[serde(default)]
  failed_count: Option<i64>, 
  #[serde(rename = "ingestedCount")]
  #[serde(default)]
  ingested_count: Option<i64>, 
  #[serde(rename = "ingestedVolume")]
  #[serde(default)]
  ingested_volume: Option<i64>, 
  #[serde(rename = "limitChangeEvents")]
  #[serde(default)]
  limit_change_events: Option<Vec<LimitChangeEventDto>>, 
  #[serde(rename = "maxAllowedMB")]
  #[serde(default)]
  max_allowed_mb: Option<i64>, 
  #[serde(rename = "maxLimitMB")]
  #[serde(default)]
  max_limit_mb: Option<i64>, 
  #[serde(rename = "start")]
  #[serde(default)]
  //Uncomment this also to deal with limited rfc support on server side
  //#[serde(serialize_with = "serialize_dt", deserialize_with = "deserialize_dt")]
  start: Option<DateTime<Utc>>, 
  #[serde(rename = "storedCount")]
  #[serde(default)]
  stored_count: Option<i64>, 
  #[serde(rename = "storedVolume")]
  #[serde(default)]
  stored_volume: Option<i64>, 
  #[serde(rename = "volumeChangeEvents")]
  #[serde(default)]
  volume_change_events: Option<Vec<LimitChangeEventDto>> 
}

impl UsageDto {
  pub fn new() -> UsageDto {
    UsageDto {
      daily_usage: None,
      daily_volume_mb: None,
      end: None,
      failed_count: None,
      ingested_count: None,
      ingested_volume: None,
      limit_change_events: None,
      max_allowed_mb: None,
      max_limit_mb: None,
      start: None,
      stored_count: None,
      stored_volume: None,
      volume_change_events: None
    }
  }

  pub fn set_daily_usage(&mut self, daily_usage: Vec<DailyDto>) {
    self.daily_usage = Some(daily_usage);
  }

  pub fn with_daily_usage(mut self, daily_usage: Vec<DailyDto>) -> UsageDto {
    self.daily_usage = Some(daily_usage);
    self
  }

  pub fn daily_usage(&self) -> Option<&Vec<DailyDto>> {
    self.daily_usage.as_ref()
  }

  pub fn reset_daily_usage(&mut self) {
    self.daily_usage = None;
  }

  pub fn set_daily_volume_mb(&mut self, daily_volume_mb: i64) {
    self.daily_volume_mb = Some(daily_volume_mb);
  }

  pub fn with_daily_volume_mb(mut self, daily_volume_mb: i64) -> UsageDto {
    self.daily_volume_mb = Some(daily_volume_mb);
    self
  }

  pub fn daily_volume_mb(&self) -> Option<&i64> {
    self.daily_volume_mb.as_ref()
  }

  pub fn reset_daily_volume_mb(&mut self) {
    self.daily_volume_mb = None;
  }

  pub fn set_end(&mut self, end: DateTime<Utc>) {
    self.end = Some(end);
  }

  pub fn with_end(mut self, end: DateTime<Utc>) -> UsageDto {
    self.end = Some(end);
    self
  }

  pub fn end(&self) -> Option<&DateTime<Utc>> {
    self.end.as_ref()
  }

  pub fn reset_end(&mut self) {
    self.end = None;
  }

  pub fn set_failed_count(&mut self, failed_count: i64) {
    self.failed_count = Some(failed_count);
  }

  pub fn with_failed_count(mut self, failed_count: i64) -> UsageDto {
    self.failed_count = Some(failed_count);
    self
  }

  pub fn failed_count(&self) -> Option<&i64> {
    self.failed_count.as_ref()
  }

  pub fn reset_failed_count(&mut self) {
    self.failed_count = None;
  }

  pub fn set_ingested_count(&mut self, ingested_count: i64) {
    self.ingested_count = Some(ingested_count);
  }

  pub fn with_ingested_count(mut self, ingested_count: i64) -> UsageDto {
    self.ingested_count = Some(ingested_count);
    self
  }

  pub fn ingested_count(&self) -> Option<&i64> {
    self.ingested_count.as_ref()
  }

  pub fn reset_ingested_count(&mut self) {
    self.ingested_count = None;
  }

  pub fn set_ingested_volume(&mut self, ingested_volume: i64) {
    self.ingested_volume = Some(ingested_volume);
  }

  pub fn with_ingested_volume(mut self, ingested_volume: i64) -> UsageDto {
    self.ingested_volume = Some(ingested_volume);
    self
  }

  pub fn ingested_volume(&self) -> Option<&i64> {
    self.ingested_volume.as_ref()
  }

  pub fn reset_ingested_volume(&mut self) {
    self.ingested_volume = None;
  }

  pub fn set_limit_change_events(&mut self, limit_change_events: Vec<LimitChangeEventDto>) {
    self.limit_change_events = Some(limit_change_events);
  }

  pub fn with_limit_change_events(mut self, limit_change_events: Vec<LimitChangeEventDto>) -> UsageDto {
    self.limit_change_events = Some(limit_change_events);
    self
  }

  pub fn limit_change_events(&self) -> Option<&Vec<LimitChangeEventDto>> {
    self.limit_change_events.as_ref()
  }

  pub fn reset_limit_change_events(&mut self) {
    self.limit_change_events = None;
  }

  pub fn set_max_allowed_mb(&mut self, max_allowed_mb: i64) {
    self.max_allowed_mb = Some(max_allowed_mb);
  }

  pub fn with_max_allowed_mb(mut self, max_allowed_mb: i64) -> UsageDto {
    self.max_allowed_mb = Some(max_allowed_mb);
    self
  }

  pub fn max_allowed_mb(&self) -> Option<&i64> {
    self.max_allowed_mb.as_ref()
  }

  pub fn reset_max_allowed_mb(&mut self) {
    self.max_allowed_mb = None;
  }

  pub fn set_max_limit_mb(&mut self, max_limit_mb: i64) {
    self.max_limit_mb = Some(max_limit_mb);
  }

  pub fn with_max_limit_mb(mut self, max_limit_mb: i64) -> UsageDto {
    self.max_limit_mb = Some(max_limit_mb);
    self
  }

  pub fn max_limit_mb(&self) -> Option<&i64> {
    self.max_limit_mb.as_ref()
  }

  pub fn reset_max_limit_mb(&mut self) {
    self.max_limit_mb = None;
  }

  pub fn set_start(&mut self, start: DateTime<Utc>) {
    self.start = Some(start);
  }

  pub fn with_start(mut self, start: DateTime<Utc>) -> UsageDto {
    self.start = Some(start);
    self
  }

  pub fn start(&self) -> Option<&DateTime<Utc>> {
    self.start.as_ref()
  }

  pub fn reset_start(&mut self) {
    self.start = None;
  }

  pub fn set_stored_count(&mut self, stored_count: i64) {
    self.stored_count = Some(stored_count);
  }

  pub fn with_stored_count(mut self, stored_count: i64) -> UsageDto {
    self.stored_count = Some(stored_count);
    self
  }

  pub fn stored_count(&self) -> Option<&i64> {
    self.stored_count.as_ref()
  }

  pub fn reset_stored_count(&mut self) {
    self.stored_count = None;
  }

  pub fn set_stored_volume(&mut self, stored_volume: i64) {
    self.stored_volume = Some(stored_volume);
  }

  pub fn with_stored_volume(mut self, stored_volume: i64) -> UsageDto {
    self.stored_volume = Some(stored_volume);
    self
  }

  pub fn stored_volume(&self) -> Option<&i64> {
    self.stored_volume.as_ref()
  }

  pub fn reset_stored_volume(&mut self) {
    self.stored_volume = None;
  }

  pub fn set_volume_change_events(&mut self, volume_change_events: Vec<LimitChangeEventDto>) {
    self.volume_change_events = Some(volume_change_events);
  }

  pub fn with_volume_change_events(mut self, volume_change_events: Vec<LimitChangeEventDto>) -> UsageDto {
    self.volume_change_events = Some(volume_change_events);
    self
  }

  pub fn volume_change_events(&self) -> Option<&Vec<LimitChangeEventDto>> {
    self.volume_change_events.as_ref()
  }

  pub fn reset_volume_change_events(&mut self) {
    self.volume_change_events = None;
  }


  pub fn validate(&self) {
  }

}


